(function(n,u){typeof exports=="object"&&typeof module<"u"?u(exports,require("three")):typeof define=="function"&&define.amd?define(["exports","three"],u):(n=typeof globalThis<"u"?globalThis:n||self,u(n.WawaVFXVanilla={},n.THREE))})(this,(function(n,u){"use strict";var H=Object.defineProperty;var j=(n,u,P)=>u in n?H(n,u,{enumerable:!0,configurable:!0,writable:!0,value:P}):n[u]=P;var r=(n,u,P)=>j(n,typeof u!="symbol"?u+"":u,P);function P(a){const i=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(a){for(const e in a)if(e!=="default"){const t=Object.getOwnPropertyDescriptor(a,e);Object.defineProperty(i,e,t.get?t:{enumerable:!0,get:()=>a[e]})}}return i.default=a,Object.freeze(i)}const s=P(u),E=a=>{let i;const e=new Set,t=(l,M)=>{const I=typeof l=="function"?l(i):l;if(!Object.is(I,i)){const y=i;i=M??(typeof I!="object"||I===null)?I:Object.assign({},i,I),e.forEach(O=>O(i,y))}},o=()=>i,h={setState:t,getState:o,getInitialState:()=>f,subscribe:l=>(e.add(l),()=>e.delete(l))},f=i=a(t,o,h);return h},x=(a=>a?E(a):E)((a,i)=>({emitters:{},shouldEmit:!0,registerEmitter:(e,t)=>{if(i().emitters[e]){console.warn(`Emitter ${e} already exists`);return}a(o=>(o.emitters[e]=t,o))},unregisterEmitter:e=>{a(t=>(delete t.emitters[e],t))},emit:(e,t,o)=>{const c=i().emitters[e];if(!c){console.warn(`Emitter ${e} not found`);return}c(t,o)}})),g=new s.Vector3,m=new s.Quaternion,A=new s.Euler,p=new s.Euler,C=new s.Vector3;class F extends s.Object3D{constructor(e,t={},o,c=!1,d=!0){super();r(this,"settings");r(this,"emitted",0);r(this,"elapsedTime",0);r(this,"currentTime",0);r(this,"shouldEmit");r(this,"emitterName");r(this,"localDirection");r(this,"store");this.emitterName=e,this.localDirection=c,this.shouldEmit=d,this.store=o||x.getState(),this.settings={duration:t.duration??1,nbParticles:t.nbParticles??1e3,spawnMode:t.spawnMode??"time",loop:t.loop??!1,delay:t.delay??0,colorStart:t.colorStart??["white","skyblue"],colorEnd:t.colorEnd??[],particlesLifetime:t.particlesLifetime??[.1,1],speed:t.speed??[5,20],size:t.size??[.1,1],startPositionMin:t.startPositionMin??[-1,-1,-1],startPositionMax:t.startPositionMax??[1,1,1],startRotationMin:t.startRotationMin??[0,0,0],startRotationMax:t.startRotationMax??[0,0,0],rotationSpeedMin:t.rotationSpeedMin??[0,0,0],rotationSpeedMax:t.rotationSpeedMax??[0,0,0],directionMin:t.directionMin??[0,0,0],directionMax:t.directionMax??[0,0,0]}}randFloat(e,t){return Math.random()*(t-e)+e}randInt(e,t){return Math.floor(Math.random()*(t-e+1))+e}stopEmitting(){this.shouldEmit=!1}startEmitting(e=!1){e&&(this.emitted=0,this.elapsedTime=0),this.shouldEmit=!0}emitAtPos(e,t=!1){if(this.settings.spawnMode!=="burst"){console.error("This function is meant to be used with burst spawn mode only.");return}const o=this.settings.nbParticles-this.emitted;t&&(this.emitted=0,this.elapsedTime=0),e&&this.position.copy(e),this.updateWorldMatrix(!0,!0),this.matrixWorld.decompose(g,m,C),A.setFromQuaternion(m),p.setFromQuaternion(m),this.store.emit(this.emitterName,o,()=>{var l;const d=this.randFloat(this.settings.size[0],this.settings.size[1]),h=this.settings.colorStart[this.randInt(0,this.settings.colorStart.length-1)],f=new s.Vector3(this.randFloat(this.settings.directionMin[0],this.settings.directionMax[0]),this.randFloat(this.settings.directionMin[1],this.settings.directionMax[1]),this.randFloat(this.settings.directionMin[2],this.settings.directionMax[2]));return this.localDirection&&f.applyQuaternion(m),{position:[g.x+this.randFloat(this.settings.startPositionMin[0],this.settings.startPositionMax[0]),g.y+this.randFloat(this.settings.startPositionMin[1],this.settings.startPositionMax[1]),g.z+this.randFloat(this.settings.startPositionMin[2],this.settings.startPositionMax[2])],direction:[f.x,f.y,f.z],scale:[d,d,d],rotation:[p.x+this.randFloat(this.settings.startRotationMin[0],this.settings.startRotationMax[0]),p.y+this.randFloat(this.settings.startRotationMin[1],this.settings.startRotationMax[1]),p.z+this.randFloat(this.settings.startRotationMin[2],this.settings.startRotationMax[2])],rotationSpeed:[this.randFloat(this.settings.rotationSpeedMin[0],this.settings.rotationSpeedMax[0]),this.randFloat(this.settings.rotationSpeedMin[1],this.settings.rotationSpeedMax[1]),this.randFloat(this.settings.rotationSpeedMin[2],this.settings.rotationSpeedMax[2])],lifetime:[this.currentTime,this.randFloat(this.settings.particlesLifetime[0],this.settings.particlesLifetime[1])],colorStart:h,colorEnd:(l=this.settings.colorEnd)!=null&&l.length?this.settings.colorEnd[this.randInt(0,this.settings.colorEnd.length-1)]:h,speed:[this.randFloat(this.settings.speed[0],this.settings.speed[1])]}})}update(e,t){if(this.currentTime=e,this.emitted<this.settings.nbParticles||this.settings.loop){if(!this.shouldEmit)return;const c=(this.settings.spawnMode==="burst"?this.settings.nbParticles:Math.max(0,Math.floor((this.elapsedTime-this.settings.delay)/this.settings.duration*this.settings.nbParticles)))-this.emitted;c>0&&this.elapsedTime>=this.settings.delay&&(this.updateWorldMatrix(!0,!0),this.matrixWorld.decompose(g,m,C),A.setFromQuaternion(m),p.setFromQuaternion(m),this.store.emit(this.emitterName,c,()=>{var M;const h=this.randFloat(this.settings.size[0],this.settings.size[1]),f=this.settings.colorStart[this.randInt(0,this.settings.colorStart.length-1)],l=new s.Vector3(this.randFloat(this.settings.directionMin[0],this.settings.directionMax[0]),this.randFloat(this.settings.directionMin[1],this.settings.directionMax[1]),this.randFloat(this.settings.directionMin[2],this.settings.directionMax[2]));return this.localDirection&&l.applyQuaternion(m),{position:[g.x+this.randFloat(this.settings.startPositionMin[0],this.settings.startPositionMax[0]),g.y+this.randFloat(this.settings.startPositionMin[1],this.settings.startPositionMax[1]),g.z+this.randFloat(this.settings.startPositionMin[2],this.settings.startPositionMax[2])],direction:[l.x,l.y,l.z],scale:[h,h,h],rotation:[p.x+this.randFloat(this.settings.startRotationMin[0],this.settings.startRotationMax[0]),p.y+this.randFloat(this.settings.startRotationMin[1],this.settings.startRotationMax[1]),p.z+this.randFloat(this.settings.startRotationMin[2],this.settings.startRotationMax[2])],rotationSpeed:[this.randFloat(this.settings.rotationSpeedMin[0],this.settings.rotationSpeedMax[0]),this.randFloat(this.settings.rotationSpeedMin[1],this.settings.rotationSpeedMax[1]),this.randFloat(this.settings.rotationSpeedMin[2],this.settings.rotationSpeedMax[2])],lifetime:[e,this.randFloat(this.settings.particlesLifetime[0],this.settings.particlesLifetime[1])],colorStart:f,colorEnd:(M=this.settings.colorEnd)!=null&&M.length?this.settings.colorEnd[this.randInt(0,this.settings.colorEnd.length-1)]:f,speed:[this.randFloat(this.settings.speed[0],this.settings.speed[1])]}}),this.emitted+=c)}this.elapsedTime+=t}updateSettings(e){Object.assign(this.settings,e)}restart(){this.emitted=0,this.elapsedTime=0}}const Q=`
#define PI 3.1415926535897932384626433832795
// Linear
float easeLinear(float t) 
{

    return t;
    
}

// --------- Power1 ---------
float easeInPower1(float t) {
    return t;
}

float easeOutPower1(float t) {
    return 1.0 - (1.0 - t);
}

float easeInOutPower1(float t) {
    return t;
}

// --------- Power2 ---------
float easeInPower2(float t) {
    return t * t;
}

float easeOutPower2(float t) {
    return 1.0 - pow(1.0 - t, 2.0);
}

float easeInOutPower2(float t) {
    return t < 0.5
        ? 2.0 * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 2.0) / 2.0;
}

// --------- Power3 ---------
float easeInPower3(float t) {
    return t * t * t;
}

float easeOutPower3(float t) {
    return 1.0 - pow(1.0 - t, 3.0);
}

float easeInOutPower3(float t) {
    return t < 0.5
        ? 4.0 * t * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
}

// --------- Power4 ---------
float easeInPower4(float t) {
    return t * t * t * t;
}

float easeOutPower4(float t) {
    return 1.0 - pow(1.0 - t, 4.0);
}

float easeInOutPower4(float t) {
    return t < 0.5
        ? 8.0 * t * t * t * t
        : 1.0 - pow(-2.0 * t + 2.0, 4.0) / 2.0;
}

// Quad
float easeInQuad(float t) {
    return t * t;
}

float easeOutQuad(float t) {
    return t * (2.0 - t);
}

float easeInOutQuad(float t) {
    return t < 0.5 
        ? 2.0 * t * t 
        : -1.0 + (4.0 - 2.0 * t) * t;
}

// Cubic
float easeInCubic(float t) {
    return t * t * t;
}

float easeOutCubic(float t) {
    float t1 = t - 1.0;
    return 1.0 + t1 * t1 * t1;
}

float easeInOutCubic(float t) {
    return t < 0.5
        ? 4.0 * t * t * t
        : (t - 1.0) * (2.0 * t - 2.0) * (2.0 * t - 2.0) + 1.0;
}

// Quart
float easeInQuart(float t) {
    return t * t * t * t;
}

float easeOutQuart(float t) {
    float t1 = t - 1.0;
    return 1.0 - t1 * t1 * t1 * t1;
}

float easeInOutQuart(float t) {
    float t1 = t - 1.0;
    return t < 0.5
        ? 8.0 * t * t * t * t
        : 1.0 - 8.0 * t1 * t1 * t1 * t1;
}

// Quint
float easeInQuint(float t) {
    return t * t * t * t * t;
}

float easeOutQuint(float t) {
    float t1 = t - 1.0;
    return 1.0 + t1 * t1 * t1 * t1 * t1;
}

float easeInOutQuint(float t) {
    float t1 = t - 1.0;
    return t < 0.5
        ? 16.0 * t * t * t * t * t
        : 1.0 + 16.0 * t1 * t1 * t1 * t1 * t1;
}

// Sine
float easeInSine(float t) {
    return -1.0 * cos(t * PI * 0.5) + 1.0;
}

float easeOutSine(float t) {
    return sin(t * PI * 0.5);
}

float easeInOutSine(float t) {
    return -0.5 * (cos(PI * t) - 1.0);
}

// Expo
float easeInExpo(float t) {
    return t == 0.0 ? 0.0 : pow(2.0, 10.0 * (t - 1.0));
}

float easeOutExpo(float t) {
    return t == 1.0 ? 1.0 : 1.0 - pow(2.0, -10.0 * t);
}

float easeInOutExpo(float t) {
    if (t == 0.0 || t == 1.0) return t;
    
    return t < 0.5
        ? 0.5 * pow(2.0, (20.0 * t) - 10.0)
        : 0.5 * (-pow(2.0, (-20.0 * t) + 10.0) + 2.0);
}

// Circ
float easeInCirc(float t) {
    return -1.0 * (sqrt(1.0 - t * t) - 1.0);
}

float easeOutCirc(float t) {
    float t1 = t - 1.0;
    return sqrt(1.0 - t1 * t1);
}

float easeInOutCirc(float t) {
    float t1 = 2.0 * t;
    float t2 = t1 - 2.0;
    return t < 0.5
        ? -0.5 * (sqrt(1.0 - t1 * t1) - 1.0)
        : 0.5 * (sqrt(1.0 - t2 * t2) + 1.0);
}

// Elastic
float easeInElastic(float t) {
    if (t == 0.0 || t == 1.0) return t;
    return -pow(2.0, 10.0 * (t - 1.0)) * sin((t - 1.075) * (2.0 * PI) / 0.3);
}

float easeOutElastic(float t) {
    if (t == 0.0 || t == 1.0) return t;
    return pow(2.0, -10.0 * t) * sin((t - 0.075) * (2.0 * PI) / 0.3) + 1.0;
}

float easeInOutElastic(float t) {
    if (t < 0.5) {
        return -0.5 * pow(2.0, 20.0 * t - 10.0) * 
               sin((20.0 * t - 11.125) * (2.0 * PI) / 4.5);
    }
    return pow(2.0, -20.0 * t + 10.0) * 
           sin((20.0 * t - 11.125) * (2.0 * PI) / 4.5) * 0.5 + 1.0;
}

// Back
float easeInBack(float t) {
    float s = 1.70158;
    return t * t * ((s + 1.0) * t - s);
}

float easeOutBack(float t) {
    float s = 1.70158;
    float t1 = t - 1.0;
    return t1 * t1 * ((s + 1.0) * t1 + s) + 1.0;
}

float easeInOutBack(float t) {
    float s = 1.70158 * 1.525;
    t *= 2.0;
    if (t < 1.0) {
        return 0.5 * (t * t * ((s + 1.0) * t - s));
    }
    t -= 2.0;
    return 0.5 * (t * t * ((s + 1.0) * t + s) + 2.0);
}

// Bounce
float easeOutBounce(float t) {
    if (t < 1.0 / 2.75) {
        return 7.5625 * t * t;
    } else if (t < 2.0 / 2.75) {
        t -= 1.5 / 2.75;
        return 7.5625 * t * t + 0.75;
    } else if (t < 2.5 / 2.75) {
        t -= 2.25 / 2.75;
        return 7.5625 * t * t + 0.9375;
    } else {
        t -= 2.625 / 2.75;
        return 7.5625 * t * t + 0.984375;
    }
}

float easeInBounce(float t) {
    return 1.0 - easeOutBounce(1.0 - t);
}

float easeInOutBounce(float t) {
    return t < 0.5
        ? (1.0 - easeOutBounce(1.0 - 2.0 * t)) * 0.5
        : (1.0 + easeOutBounce(2.0 * t - 1.0)) * 0.5;
}

float applyEasing(float t, int easingId) {
    if (easingId == 0) return easeLinear(t);
    else if (easingId == 1) return easeInPower1(t);
    else if (easingId == 2) return easeOutPower1(t);
    else if (easingId == 3) return easeInOutPower1(t);
    else if (easingId == 4) return easeInPower2(t);
    else if (easingId == 5) return easeOutPower2(t);
    else if (easingId == 6) return easeInOutPower2(t);
    else if (easingId == 7) return easeInPower3(t);
    else if (easingId == 8) return easeOutPower3(t);
    else if (easingId == 9) return easeInOutPower3(t);
    else if (easingId == 10) return easeInPower4(t);
    else if (easingId == 11) return easeOutPower4(t);
    else if (easingId == 12) return easeInOutPower4(t);
    else if (easingId == 13) return easeInQuad(t);
    else if (easingId == 14) return easeOutQuad(t);
    else if (easingId == 15) return easeInOutQuad(t);
    else if (easingId == 16) return easeInCubic(t);
    else if (easingId == 17) return easeOutCubic(t);
    else if (easingId == 18) return easeInOutCubic(t);
    else if (easingId == 19) return easeInQuart(t);
    else if (easingId == 20) return easeOutQuart(t);
    else if (easingId == 21) return easeInOutQuart(t);
    else if (easingId == 22) return easeInQuint(t);
    else if (easingId == 23) return easeOutQuint(t);
    else if (easingId == 24) return easeInOutQuint(t);
    else if (easingId == 25) return easeInSine(t);
    else if (easingId == 26) return easeOutSine(t);
    else if (easingId == 27) return easeInOutSine(t);
    else if (easingId == 28) return easeInExpo(t);
    else if (easingId == 29) return easeOutExpo(t);
    else if (easingId == 30) return easeInOutExpo(t);
    else if (easingId == 31) return easeInCirc(t);
    else if (easingId == 32) return easeOutCirc(t);
    else if (easingId == 33) return easeInOutCirc(t);
    else if (easingId == 34) return easeInElastic(t);
    else if (easingId == 35) return easeOutElastic(t);
    else if (easingId == 36) return easeInOutElastic(t);
    else if (easingId == 37) return easeInBack(t);
    else if (easingId == 38) return easeOutBack(t);
    else if (easingId == 39) return easeInOutBack(t);
    else if (easingId == 40) return easeInBounce(t);
    else if (easingId == 41) return easeOutBounce(t);
    else if (easingId == 42) return easeInOutBounce(t);
    // fallback
    return t;
}

`;var S=(a=>(a[a.Square=0]="Square",a[a.Circular=1]="Circular",a))(S||{}),w=(a=>(a.StretchBillboard="stretchBillboard",a.Billboard="billboard",a.Mesh="mesh",a))(w||{});const z=["easeLinear","easeInPower1","easeOutPower1","easeInOutPower1","easeInPower2","easeOutPower2","easeInOutPower2","easeInPower3","easeOutPower3","easeInOutPower3","easeInPower4","easeOutPower4","easeInOutPower4","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce"],B=new s.Vector3,b=new s.Euler,R=new s.Quaternion,U=new s.Vector3(1,1,1),D=new s.Matrix4,v=new s.Color;class L{constructor(i,e={},t,o,c){r(this,"mesh");r(this,"material");r(this,"settings");r(this,"cursor",0);r(this,"lastCursor",0);r(this,"needsUpdate",!1);r(this,"name");r(this,"store");r(this,"clock");r(this,"attributeArrays");this.name=i,this.store=t||x.getState(),this.clock=new s.Clock,this.settings={nbParticles:e.nbParticles??1e3,intensity:e.intensity??1,renderMode:e.renderMode??w.Mesh,stretchScale:e.stretchScale??1,fadeSize:e.fadeSize??[.1,.9],fadeAlpha:e.fadeAlpha??[0,1],gravity:e.gravity??[0,0,0],frustumCulled:e.frustumCulled??!0,appearance:e.appearance??S.Square,easeFunction:e.easeFunction??"easeLinear",blendingMode:e.blendingMode??s.AdditiveBlending,shadingHooks:e.shadingHooks??{},side:e.side??s.FrontSide};const d=c||new s.PlaneGeometry(.5,.5);this.attributeArrays={instanceColor:new Float32Array(this.settings.nbParticles*3),instanceColorEnd:new Float32Array(this.settings.nbParticles*3),instanceDirection:new Float32Array(this.settings.nbParticles*3),instanceLifetime:new Float32Array(this.settings.nbParticles*2),instanceSpeed:new Float32Array(this.settings.nbParticles*1),instanceRotationSpeed:new Float32Array(this.settings.nbParticles*3)},this.material=this.createMaterial(o),this.mesh=new s.InstancedMesh(d,this.material,this.settings.nbParticles),this.mesh.frustumCulled=this.settings.frustumCulled,this.setupAttributes(),this.store.registerEmitter(i,this.emit.bind(this))}createMaterial(i){const e=z.indexOf(this.settings.easeFunction),t={STRETCH_BILLBOARD_MODE:this.settings.renderMode==="stretchBillboard",BILLBOARD_MODE:this.settings.renderMode==="billboard",MESH_MODE:this.settings.renderMode==="mesh"};return i&&(t.USE_ALPHAMAP=!0),new s.ShaderMaterial({uniforms:{uTime:{value:0},uIntensity:{value:this.settings.intensity},uStretchScale:{value:this.settings.stretchScale},uFadeSize:{value:this.settings.fadeSize},uFadeAlpha:{value:this.settings.fadeAlpha},uGravity:{value:this.settings.gravity},uAppearanceMode:{value:this.settings.appearance},alphaMap:{value:i||null},uEasingFunction:{value:e}},defines:t,vertexShader:`
${Q}
mat4 rotationX(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
      1,  0,  0,  0,
      0,  c, -s,  0,
      0,  s,  c,  0,
      0,  0,  0,  1
  );
}

mat4 rotationY(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
        c,  0,  s,  0,
        0,  1,  0,  0,
      -s,  0,  c,  0,
        0,  0,  0,  1
  );
}

mat4 rotationZ(float angle) {
  float s = sin(angle);
  float c = cos(angle);
  return mat4(
      c, -s,  0,  0,
      s,  c,  0,  0,
      0,  0,  1,  0,
      0,  0,  0,  1
  );
}

vec3 billboard(vec2 v, mat4 view) {
  vec3 up = vec3(view[0][1], view[1][1], view[2][1]);
  vec3 right = vec3(view[0][0], view[1][0], view[2][0]);
  vec3 p = right * v.x + up * v.y;
  return p;
}

uniform float uTime;
uniform vec2 uFadeSize;
uniform vec3 uGravity;
uniform float uStretchScale;
uniform int uEasingFunction;

${this.settings.shadingHooks.customUniforms||""}

varying vec2 vUv;
varying vec3 vColor;
varying vec3 vColorEnd;
varying float vProgress;

${this.settings.shadingHooks.customVaryings||""}

attribute float instanceSpeed;
attribute vec3 instanceRotationSpeed;
attribute vec3 instanceDirection;
attribute vec3 instanceColor;
attribute vec3 instanceColorEnd;
attribute vec2 instanceLifetime;

${this.settings.shadingHooks.vertexBeforeMain||""}

void main() {
  float startTime = instanceLifetime.x;
  float duration = instanceLifetime.y;
  float age = uTime - startTime;

  age = instanceSpeed < 0.0 ? duration - (uTime - startTime) : uTime - startTime;
  float progress = clamp(age / duration, 0.0, 1.0);
  vProgress = applyEasing(progress, uEasingFunction);

  if (progress < 0.0 || progress >= 1.0) {
    vProgress = progress;
    gl_Position = vec4(vec3(9999.0), 1.0);
    return;
  }

  float scale = smoothstep(0.0, uFadeSize.x, vProgress) * smoothstep(1.01, uFadeSize.y, vProgress);

  vec3 normalizedDirection = length(instanceDirection) > 0.0 ? normalize(instanceDirection) : vec3(0.0);
  vec3 gravityForce = 0.5 * uGravity * (age * age);
  float easedAge = vProgress * duration;
  vec3 offset = normalizedDirection * easedAge * instanceSpeed;
  offset += gravityForce;

  vec3 rotationSpeed = instanceRotationSpeed * age;
  mat4 rotX = rotationX(rotationSpeed.x);
  mat4 rotY = rotationY(rotationSpeed.y);
  mat4 rotZ = rotationZ(rotationSpeed.z);
  mat4 rotationMatrix = rotZ * rotY * rotX;

  vec4 mvPosition;
  #ifdef MESH_MODE
    vec4 startPosition = modelMatrix * instanceMatrix * rotationMatrix * vec4(position * scale, 1.0);
    vec3 instancePosition = startPosition.xyz;
    vec3 finalPosition = instancePosition + offset;
    mvPosition = modelViewMatrix * vec4(finalPosition, 1.0);
  #endif
  #ifdef BILLBOARD_MODE
    vec3 instancePosition = (instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;
    vec3 localZ = normalize(cameraPosition - instancePosition);
    vec3 worldUp = vec3(0.0, 1.0, 0.0);
    vec3 localX = normalize(cross(worldUp, localZ));
    vec3 localY = cross(localZ, localX);
    mat3 billboardMatrix = mat3(localX, localY, localZ);
    float scaleX = length(instanceMatrix[0].xyz);
    float scaleY = length(instanceMatrix[1].xyz);
    float scaleZ = length(instanceMatrix[2].xyz);
    vec3 instanceScale = vec3(scaleX, scaleY, scaleZ);

    // Extract initial Z rotation from instanceMatrix
    float initialRotZ = atan(instanceMatrix[0].y / scaleX, instanceMatrix[0].x / scaleX);
    mat4 initialRotZMatrix = rotationZ(initialRotZ);

    // Combine initial rotation with dynamic rotation
    mat3 finalMatrix = billboardMatrix * mat3(initialRotZMatrix * rotationMatrix);
    vec3 finalRight = finalMatrix[0] * instanceScale * scale;
    vec3 finalUp = finalMatrix[1] * instanceScale * scale;
    vec3 vertexWorldPos = instancePosition + finalRight * position.x + finalUp * position.y;
    mvPosition = viewMatrix * vec4(vertexWorldPos, 1.0);
  #endif
  #ifdef STRETCH_BILLBOARD_MODE
    vec3 particleWorldPos = (instanceMatrix * vec4(0.0, 0.0, 0.0, 1.0)).xyz + offset;
    vec3 worldVelocity = normalizedDirection * instanceSpeed + uGravity * age;
    float currentSpeed = length(worldVelocity);
    if (currentSpeed < 0.001) {
      vec3 instancePositionBillboard = particleWorldPos;
      vec3 camUpWorld = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));
      vec3 eyeVecBillboard = normalize(cameraPosition - instancePositionBillboard);
      vec3 bLocalX = normalize(cross(camUpWorld, eyeVecBillboard));
      if (length(bLocalX) < 0.001) {
        bLocalX = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
      }
      vec3 bLocalY = normalize(cross(eyeVecBillboard, bLocalX));
      mat3 billboardBasis = mat3(bLocalX, bLocalY, eyeVecBillboard);
      float instScaleX = length(instanceMatrix[0].xyz);
      float instScaleY = length(instanceMatrix[1].xyz);
      mat3 rotatedBillboardBasis = billboardBasis * mat3(rotationMatrix);
      vec3 finalRight = rotatedBillboardBasis[0] * instScaleX * scale;
      vec3 finalUp = rotatedBillboardBasis[1] * instScaleY * scale;
      vec3 vertexWorldPos = instancePositionBillboard + finalRight * position.x + finalUp * position.y;
      mvPosition = viewMatrix * vec4(vertexWorldPos, 1.0);
    } else { 
      vec3 eyeVector = normalize(cameraPosition - particleWorldPos);
      vec3 tangent = normalize(worldVelocity); 
      vec3 projectedTangent = tangent - dot(tangent, eyeVector) * eyeVector;
      vec3 particlePlaneUp;
      vec3 particlePlaneRight; 
      if (length(projectedTangent) < 0.001) {
        particlePlaneUp = tangent;
        vec3 camUpWorld = normalize(vec3(viewMatrix[0][1], viewMatrix[1][1], viewMatrix[2][1]));
        particlePlaneRight = normalize(cross(particlePlaneUp, camUpWorld));
        if (length(particlePlaneRight) < 0.001) {
          vec3 camRightWorld = normalize(vec3(viewMatrix[0][0], viewMatrix[1][0], viewMatrix[2][0]));
          particlePlaneRight = normalize(cross(particlePlaneUp, camRightWorld));
        }
      } else {
        particlePlaneUp = normalize(projectedTangent);
        particlePlaneRight = normalize(cross(particlePlaneUp, eyeVector));
      }
      float baseWidth = length(instanceMatrix[0].xyz);
      float baseLength = length(instanceMatrix[1].xyz);
      float wid = baseWidth * scale;
      float len = baseLength * scale * (1.0 + currentSpeed * uStretchScale);
      float zAngle = instanceRotationSpeed.z * age;
      mat2 spinMatrix = mat2(cos(zAngle), -sin(zAngle), sin(zAngle), cos(zAngle));
      vec2 localSpunPos = spinMatrix * position.xy;
      vec3 worldSpaceVertexOffset = particlePlaneRight * localSpunPos.x * wid + particlePlaneUp * localSpunPos.y * len;
      vec3 finalVertexPos = particleWorldPos + worldSpaceVertexOffset;
      mvPosition = viewMatrix * vec4(finalVertexPos, 1.0);
    }
  #endif


  ${this.settings.shadingHooks.vertexBeforeOutput||""}
  gl_Position = projectionMatrix * mvPosition;
  vUv = uv;
  vColor = instanceColor;
  vColorEnd = instanceColorEnd;
}
`,fragmentShader:`
uniform float uTime;
uniform float uIntensity;
uniform vec2 uFadeAlpha;
uniform sampler2D alphaMap;
uniform int uAppearanceMode;

${this.settings.shadingHooks.customUniforms||""}

varying vec3 vColor;
varying vec3 vColorEnd;
varying float vProgress;
varying vec2 vUv;

${this.settings.shadingHooks.customVaryings||""}

${this.settings.shadingHooks.fragmentBeforeMain||""}

void main() {
  if (vProgress < 0.0 || vProgress > 1.0) {
    discard;
  }
  vec3 finalColor = mix(vColor, vColorEnd, vProgress);
  finalColor *= uIntensity;

  float alpha = smoothstep(0.0, uFadeAlpha.x, vProgress) * smoothstep(1.01, uFadeAlpha.y, vProgress);

  #ifdef USE_ALPHAMAP
    vec2 uv = vUv;
    vec4 tex = texture2D(alphaMap, uv);
    alpha = tex.a * alpha;
  #else
    if(uAppearanceMode == 1){
      vec2 center = vec2(0.5);
      float dist = distance(vUv, center);
      if(dist > 0.5){
        discard;
      }
    }
  #endif
  ${this.settings.shadingHooks.fragmentBeforeOutput||""}
  gl_FragColor = vec4(finalColor, alpha);
}`,transparent:!0,blending:this.settings.blendingMode,depthWrite:!1,side:this.settings.side})}setupAttributes(){const i=this.mesh.geometry;i.setAttribute("instanceColor",new s.InstancedBufferAttribute(this.attributeArrays.instanceColor,3)),i.setAttribute("instanceColorEnd",new s.InstancedBufferAttribute(this.attributeArrays.instanceColorEnd,3)),i.setAttribute("instanceDirection",new s.InstancedBufferAttribute(this.attributeArrays.instanceDirection,3)),i.setAttribute("instanceLifetime",new s.InstancedBufferAttribute(this.attributeArrays.instanceLifetime,2)),i.setAttribute("instanceSpeed",new s.InstancedBufferAttribute(this.attributeArrays.instanceSpeed,1)),i.setAttribute("instanceRotationSpeed",new s.InstancedBufferAttribute(this.attributeArrays.instanceRotationSpeed,3)),i.attributes.instanceColor.setUsage(s.DynamicDrawUsage),i.attributes.instanceColorEnd.setUsage(s.DynamicDrawUsage),i.attributes.instanceDirection.setUsage(s.DynamicDrawUsage),i.attributes.instanceLifetime.setUsage(s.DynamicDrawUsage),i.attributes.instanceSpeed.setUsage(s.DynamicDrawUsage),i.attributes.instanceRotationSpeed.setUsage(s.DynamicDrawUsage)}emit(i,e){const t=this.mesh.geometry.getAttribute("instanceColor"),o=this.mesh.geometry.getAttribute("instanceColorEnd"),c=this.mesh.geometry.getAttribute("instanceDirection"),d=this.mesh.geometry.getAttribute("instanceLifetime"),h=this.mesh.geometry.getAttribute("instanceSpeed"),f=this.mesh.geometry.getAttribute("instanceRotationSpeed");for(let l=0;l<i;l++){this.cursor>=this.settings.nbParticles&&(this.cursor=0);const{scale:M,rotation:I,rotationSpeed:y,position:O,direction:T,lifetime:V,colorStart:k,colorEnd:X,speed:W}=e();B.set(...O),b.set(...I),(this.settings.renderMode==="billboard"||this.settings.renderMode==="stretchBillboard")&&(b.x=0,b.y=0),R.setFromEuler(b),U.set(...M),D.compose(B,R,U),this.mesh.setMatrixAt(this.cursor,D),v.set(k),t.set([v.r,v.g,v.b],this.cursor*3),v.set(X),o.set([v.r,v.g,v.b],this.cursor*3),c.set(T,this.cursor*3),d.set(V,this.cursor*2),h.set(W,this.cursor),f.set(y,this.cursor*3),this.cursor++,this.cursor=this.cursor%this.settings.nbParticles}this.mesh.instanceMatrix.needsUpdate=!0,t.needsUpdate=!0,o.needsUpdate=!0,c.needsUpdate=!0,d.needsUpdate=!0,h.needsUpdate=!0,f.needsUpdate=!0,this.needsUpdate=!0}update(i){const e=i??this.clock.getElapsedTime();this.material.uniforms.uTime.value=e,this.material.uniforms.uIntensity.value=this.settings.intensity,this.material.uniforms.uStretchScale.value=this.settings.stretchScale,this.material.uniforms.uFadeSize.value=this.settings.fadeSize,this.material.uniforms.uFadeAlpha.value=this.settings.fadeAlpha,this.material.uniforms.uGravity.value=this.settings.gravity,this.material.uniforms.uAppearanceMode.value=this.settings.appearance,this.material.uniforms.uEasingFunction.value=z.indexOf(this.settings.easeFunction),this.needsUpdate&&(this.updateAttributeRanges(),this.needsUpdate=!1)}updateAttributeRanges(){[this.mesh.instanceMatrix,this.mesh.geometry.getAttribute("instanceColor"),this.mesh.geometry.getAttribute("instanceColorEnd"),this.mesh.geometry.getAttribute("instanceDirection"),this.mesh.geometry.getAttribute("instanceLifetime"),this.mesh.geometry.getAttribute("instanceSpeed"),this.mesh.geometry.getAttribute("instanceRotationSpeed")].forEach(e=>{const t=e;t.clearUpdateRanges(),this.lastCursor>this.cursor?(t.addUpdateRange(0,this.cursor*t.itemSize),t.addUpdateRange(this.lastCursor*t.itemSize,this.settings.nbParticles*t.itemSize-this.lastCursor*t.itemSize)):t.addUpdateRange(this.lastCursor*t.itemSize,this.cursor*t.itemSize-this.lastCursor*t.itemSize),t.needsUpdate=!0}),this.lastCursor=this.cursor}getMesh(){return this.mesh}updateSettings(i){Object.assign(this.settings,i)}dispose(){this.store.unregisterEmitter(this.name),this.mesh.geometry.dispose(),this.material.dispose()}}n.AppearanceMode=S,n.RenderMode=w,n.VFXEmitter=F,n.VFXEmitterCore=F,n.VFXParticles=L,n.VFXParticlesCore=L,n.vfxStore=x,Object.defineProperty(n,Symbol.toStringTag,{value:"Module"})}));
