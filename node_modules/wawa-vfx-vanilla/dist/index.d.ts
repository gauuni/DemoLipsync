import { StoreApi } from 'zustand/vanilla';
import * as THREE from 'three';

export declare enum AppearanceMode {
    Square = 0,
    Circular = 1
}

export declare type EaseFunction = "easeLinear" | "easeInPower1" | "easeOutPower1" | "easeInOutPower1" | "easeInPower2" | "easeOutPower2" | "easeInOutPower2" | "easeInPower3" | "easeOutPower3" | "easeInOutPower3" | "easeInPower4" | "easeOutPower4" | "easeInOutPower4" | "easeInQuad" | "easeOutQuad" | "easeInOutQuad" | "easeInCubic" | "easeOutCubic" | "easeInOutCubic" | "easeInQuart" | "easeOutQuart" | "easeInOutQuart" | "easeInQuint" | "easeOutQuint" | "easeInOutQuint" | "easeInSine" | "easeOutSine" | "easeInOutSine" | "easeInExpo" | "easeOutExpo" | "easeInOutExpo" | "easeInCirc" | "easeOutCirc" | "easeInOutCirc" | "easeInElastic" | "easeOutElastic" | "easeInOutElastic" | "easeInBack" | "easeOutBack" | "easeInOutBack" | "easeInBounce" | "easeOutBounce" | "easeInOutBounce";

export declare interface EmitCallbackSettings {
    position: [number, number, number];
    direction: [number, number, number];
    scale: [number, number, number];
    rotation: [number, number, number];
    rotationSpeed: [number, number, number];
    lifetime: [number, number];
    colorStart: string;
    colorEnd: string;
    speed: [number];
}

declare interface EmitCallbackSettings_2 {
    position: [number, number, number];
    direction: [number, number, number];
    scale: [number, number, number];
    rotation: [number, number, number];
    rotationSpeed: [number, number, number];
    lifetime: [number, number];
    colorStart: string;
    colorEnd: string;
    speed: [number];
}

export declare type EmitCallbackSettingsFn = () => EmitCallbackSettings;

declare type EmitCallbackSettingsFn_2 = () => EmitCallbackSettings_2;

export declare enum RenderMode {
    StretchBillboard = "stretchBillboard",
    Billboard = "billboard",
    Mesh = "mesh"
}

declare interface ShadingHooks {
    customUniforms?: string;
    customVaryings?: string;
    vertexBeforeMain?: string;
    vertexBeforeOutput?: string;
    fragmentBeforeMain?: string;
    fragmentBeforeOutput?: string;
}

declare class VFXEmitterCore extends THREE.Object3D {
    private settings;
    private emitted;
    private elapsedTime;
    private currentTime;
    private shouldEmit;
    private emitterName;
    private localDirection;
    private store;
    constructor(emitterName: string, settings?: VFXEmitterSettings, store?: ReturnType<typeof vfxStore.getState>, localDirection?: boolean, autoStart?: boolean);
    private randFloat;
    private randInt;
    stopEmitting(): void;
    startEmitting(reset?: boolean): void;
    emitAtPos(position: THREE.Vector3 | null, reset?: boolean): void;
    update(time: number, delta: number): void;
    updateSettings(settings: VFXEmitterSettings): void;
    restart(): void;
}
export { VFXEmitterCore as VFXEmitter }
export { VFXEmitterCore }

export declare interface VFXEmitterSettings {
    duration?: number;
    nbParticles?: number;
    spawnMode?: "time" | "burst";
    loop?: boolean;
    delay?: number;
    colorStart?: string[];
    colorEnd?: string[];
    particlesLifetime?: [number, number];
    speed?: [number, number];
    size?: [number, number];
    startPositionMin?: [number, number, number];
    startPositionMax?: [number, number, number];
    startRotationMin?: [number, number, number];
    startRotationMax?: [number, number, number];
    rotationSpeedMin?: [number, number, number];
    rotationSpeedMax?: [number, number, number];
    directionMin?: [number, number, number];
    directionMax?: [number, number, number];
}

declare class VFXParticlesCore {
    private mesh;
    private material;
    private settings;
    private cursor;
    private lastCursor;
    private needsUpdate;
    private name;
    private store;
    private clock;
    private attributeArrays;
    constructor(name: string, settings?: VFXParticlesSettings, store?: ReturnType<typeof vfxStore.getState>, alphaMap?: THREE.Texture, geometry?: THREE.BufferGeometry);
    private createMaterial;
    private setupAttributes;
    private emit;
    update(time?: number): void;
    private updateAttributeRanges;
    getMesh(): THREE.InstancedMesh;
    updateSettings(settings: VFXParticlesSettings): void;
    dispose(): void;
}
export { VFXParticlesCore as VFXParticles }
export { VFXParticlesCore }

export declare interface VFXParticlesSettings {
    nbParticles?: number;
    intensity?: number;
    renderMode?: RenderMode;
    stretchScale?: number;
    fadeSize?: [number, number];
    fadeAlpha?: [number, number];
    gravity?: [number, number, number];
    frustumCulled?: boolean;
    appearance?: AppearanceMode;
    easeFunction?: EaseFunction;
    blendingMode?: THREE.Blending;
    shadingHooks?: ShadingHooks;
    side?: THREE.Side;
}

declare interface VFXStore {
    emitters: Record<string, (...args: any[]) => void>;
    shouldEmit: boolean;
    registerEmitter: (name: string, emitter: (...args: any[]) => void) => void;
    unregisterEmitter: (name: string) => void;
    emit: (name: string, rate: number, callback: EmitCallbackSettingsFn_2) => void;
}

export declare const vfxStore: StoreApi<VFXStore>;

export { }
